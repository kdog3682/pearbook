/* deno-fmt-ignore */ import {maybe, mapkv, resolveObject, inside, splitOnceReverse, getTestData, fooga, denoDebug, denobug, isAbsolutePath, templater3, splitInHalf, pop4, map4, visit, AbstractVisitor, shellEscape, getkv, toggleBooleanState, numbered, noidea, assertObjectValue, assertValue, getClasses, exit, choose, getFileName, testEqual, pause, getBindingValueString, templater2, smartDedent5, pop3, moduleExports, joinPath, expandPath, isDecimal, hasPercentage, ass, parsePercentage, Matrix, isInteger, isEquation, isObjectObject, getExtraIndent, shellUnescape, assertEqual, asyncToggle, touched, chosen, lastOf, firstOf, isBlockEnter, group3, loremIpsum, exportString, deepToggle, maybeNewlineIndent, onAndOff, flattenModule, isModule, isNativeHtmlTag, partitionByValues, strcall, getLongest2, must, mconfig, unreachable, notify, storager, joiner, removeVeryStartingComments, ireplace, removeCommentsInPlace, editf, getLineTokens, IndexedStore, abstractError, bool, xassert, getSetLines, inMiddle, replaceLast, ensureExtension, multipleReplacer, getGradeLevel, constructEdit, getYear, Modulus, wrapClassMethods, proseReplacer, parseComments, parseFunctionDictComments, todo, dictAssertion, boundModularIncrement, construct, reduceToString2, pageTurner, assignCumulative, defaultMergeStrategy, dictSetter3, toArguments, reTemplate, parseFrontmatter, typeAssertion, defineGetter, assignAllowed, simpleRecursiveWalk, simpleArgument, exprTemplater, stringifyIfNotPrimitive, panic, stringerf, wrapFunction, regexTemplater, iso8601, strftime, walkChildEntries, getFiletype, matchf, isUrl, looksLikeFunction, toArgument2, notNull, CumulativeStorage2, simpleAssign, findAndMatch, infuseObjectArray, regexGetter, splitArg, isJavascriptComment, runTest, everyOther, splitByRange, get_regex, getImports, isJavascriptFile, isValidDateString, WriteObject, equalityf, group2, splitOnce2, dedent4, isLowerCase, looksLikeRegExpString, isRegExpString, getDependencies, camelSplit, toggle3, countf, isLiteralObject, bindMethodsAndState2, call, mget3, looks_like_object_function, create_functions_from_master, toStringArgumentPretty, codeChunks, smart_map, run_tests, hasStartingCallable, mapTemplate, aliaser, fixSelector, htmlTags, removePythonComments, simpleStringBreaker, colonConfig, operations, error, redColon, so2, group, parseSingleLineJson, Items, findDependencies, tryf, find4, localeString, cssComment, colonConfigf, trimArray, parseCallable, bringToLifeTextFix, localBringToLife, getCaller4, getErrorStack, forEach, getBindings, getExports, matchstr, filter4, allEqual, count, isNativeFunction, repeat, eat, getIndentAndText, StopWatch, stringDictSetter, getFunctionInfo, runRef, toLines, hasCallable, getProseWords, tally, paramify, codeSplit, debugConfig, logConfig, blueColon, toStringArgument3, stringCallable, simpleBinding, dashSplit4, appendBelow, appendAbove, removeLineComments, prependIfNecessary, smartDedent4, blueSandwich, walk4, findLineIndex, parseAB, applyTransform, kebabCase, getExcerpt, sortObject, buildFunction, maybeSort, parseFunction, isTypable, frontMatter, dictEntry, insertAfterIndex, State, bindMethods, cpop, tagRE, toggle2, createFunction2, assignIncrementedIndex, ufa, assignArray, regexFromComment, createParsersFromObject, imatch, globalConsoleDebug, bindMethodsAndState, isQuestion, oxfordComma, isUpperCase, getFunctionIdentifier, filter3, match, getMatch, alternatef, reCombine, assertion2, deepEqual, hasDollar, so, Tally, getFunctionNames, throwError, notEqual, tryString, prettyPrintCodeSnippet, prettyPrintErrorStack, iter, quotify, transformerf, assign, defineBinding, jspy, linebreak, stringCall2, reduce3, getClassParameters, assignOnTop2, isIdentifier, ndy, dashSplit3, runFunctionFromRef, equalf, alphabet, stateGetterFromSchema, mreplace, require, topLineComment, isChinese, replacef, ignoref, codeLibrary, splitLines, addArgumentQuotes, getBindings2, addCaret, mget2, getStartingConfig, incrementalEat, strlen, hr, setOnce, unescapeHtml, oxford, breakerf, runTests, map3, dateSplit, transformDict, walk3, toRegExp, tryAgainf, assertNotNull, getArgumentObject, isArgumentObject, typef, requireArg, keyAndValue, assignf, stateGetter3, objectFromArguments2, assignDefaults, transformValue, assign3, assignFresh3, evaluate3, scopedEvaluator, objectFromArguments, enforce, sub, filterObject, extractStartingJsonLikeConfig, unbrackify, newlineIndent2, deleteLine, both, normalizeIndent, getComment, secondComment, isStringRegExp, dashSplit2, clock, warning, errorStringify, alert, labelCase, bottomComment, stringCompose, getAnyIdentifier, chalkf, getNumbers, partitions, has, addUnit, toCallable, unquote, filter2, warn2, join2, caller2, assignOnce, longShort, shortLong, argPop, caller, assignOnTop, toggle, defineWindow, unescapeNewlines, escapeQuotes, unescapeQuotes, escapeNewlines, setAliases, announceCaller, removeStartingComments, smartBind, assignExisting, isObjectWithKey, eatStart, modularIncrementItem, getRegex, runFunction, isObjectLikeArray, itemGetter2, getAllKeys, prefixSlice, hasQuotes, assertion, diff, toggleState, initState, dunder, objectGetter, superTransform, popFilter, testRunner, assert2, insertAtDollar, popEmptyLine, getOptions, mergeSpecs, sortByKeys, map2, strictMessengerAssert, smartSplit, chalk4, typeLog, getFunctionName, Clock, search3, MyError, fuzzyMatch3, debugDisplay, getCaller3, messengerAssert, camelSlice, setPrototype, assignAliases, display, modifyNumber, toDict, setPush, modularIncrementIndex, longstamp, popIndex, toggleOnOff, locWrap, walk2, typeMatch, prettyStringify, getIdentifiers, CustomError, argMatch, brackify2, smartestDedent, modularIncrementNumber, AbstractMethodError, allUnique, Trie, boundarySplit, numberBoundarySplit, nodeLog, getFirst, defineProperty, supermix, partial, timeLog, timestamp, raise, getIdentifier, conditionalPrefix, conditionalSuffix, QueryList, fuzzyMatch2, buildDict, getTextAndCommand, sprawlFactory, getParameters2, pushf, intersection, union, blue, green, sandwich, getLastSpaces, smartDedent3, red, sort, debounce, checkValue, getCodeChunks, logf, boundary, myError, conditional, isStringFunction, toSpaces, objectf, searchAll, difference, singleQuote, itemGetter, slice2, mergeObjects, once, dashSplit, nchalk, coerceToObject, ArrayState, exporter2, indent2, iterator, removeAllComments, countParams, cumulativeSchemaAssign, argKwargSplit, argParse, removeInlineComments, getFrontMatter, hasHtmlSuffix, lazyArray, isThisFunction, escapeHTML, getKwargs2, search2, toStringArgument, createFuzzyMatch, edit2, splice, zip, merge2, argArgsKwargs, fill2, chalk, vueWrap, splitArray, splitArray2, warn, makeRunner2, searchf2, smartDedent2, dedent2, toArray2, stateGetter2, sortByIndex, IndexedCache, argo, curry2, doUntil2, evaluate2, findall2, findIndex2, findItem2, getCaller2, getErrorStack2, isJson, indexGetter2, insert2, pop2, parseError2, remove2, reduce2, testf2, type2, unshift2, waterfall2, xsplit2, Cache, cumulativeAssign, replaceBefore, topComment, isAsyncFunction, mapSort, getFileURI, getQuotes, isClassObject, isInitialized, getFallback, bindingRE, addObjectOrObjectProperty, forDoubles, isCss, log, iterate, backAndForth, round, iteratorWrapper, toJSON, isFromMap, toString, empty, conditionalString, getConfigArg, hasKey, errorWrap, successWrap, check, toPoints, bind, mixinAliases, isPercentage, isBasicType, reducerStrategy, gather, entries, stateGetter, methodCase, vueCase, push2, smarterIndent, lineSplit, Store, isSingleLetter, prepareText, isSymbol, getShortest, slice, KeyError, deepCopy, argsKwargs, isError, isColor, list, objectEditor, matchall, makeFastRunner, announce, hasLetter, filter, reduce, stringCall, capitalizeName, stop, proseCase, lineDitto, mixinSetters, modularIncrement, distinct, definedSort, groupBy, reWrap2, fuzzyMatch, isPlural, parseError, isPrimitiveArray, callableArgsKwargs, waterfall, defineVariable, info, flat2D, splitThePage, handleError, dedent, TypeAssertion, createFunction, pluralize, remove, Group, PageStorage, Storage, UniqueStorage, Watcher, arrayToDict, addProperty, addQuotes, argWrapFactory, assert, abrev, abf, addExtension, assignFresh, antif, atFirst, atSecond, backspace, bindObject, breaker, blockQuote, brackify, bringToLife, comment, countCaptureGroups, capitalizeTitle, classMixin, callableRE, camelToTitle, curry, createVariable, changeExtension, curryStart, curryEnd, capitalize, copy, camelCase, compose, char2n, camelToDash, deepMerge, datestamp, doublef, dictSetter2, dsearch, doUntil, dashCase, doubleQuote, dict, depluralize, dreplace, dictf, endsWithWord, exporter, edit, exists, evaluate, extend, find, flatMap, fill, fixUrl, functionGetter, findall, fixPath, flat, fparse, findIndex, firstLine, ftest, getKwargs, getFirstName, getBindingName, getParameters, getLastWord, getCodeWords, getCodeWords2, getIndent, getExtension, getLast, getLongest, getChunks, getCaller, getStackTrace, getConstructorName, getFirstWord, getWords, getSpaces, hasComma, hasSpaces, hasHtml, hasBracket, hasNewline, hasCaptureGroup, hasEquals, hasValue, hasCamelCase, hasNumber, hackReplace, insert, indexGetter, incrementf, isCallable, isQuote, isEven, isOdd, isLast, isHTML, isNode, interweave, inferLang, isString, isArray, isObject, isDefined, isFunction, isPrimitive, isNumber, isSet, isNestedArray, indent, isNull, isWord, isBoolean, isRegExp, identity, isObjectLiteral, isJsonParsable, isCapitalized, isNewLine, isObjectArray, isStringArray, isClassFunction, joinSpaces, join, keyArrayToObject, lowerCase, linebreakRE, len, lineGetter, lineCount, lastLine, logConsole, makeRunner, mixin, modularf, matchGetter, merge, mget, map, mergeOnTop, mergeToObject, mapFilter, noop, nestPush, no, newlineIndent, n2char, objectWalk, overlap, objectToString, opposite, pipe, parseTopAttrs, pascalCase, partition, parens, push, pop, parseJSON, rigidSort, removeQuotes, rep, removeComments, range, removeExtension, rescape, reverse, reWrap, reduceToString, repeatUntil, swapKey, sayhi, swap, splitMapJoin, splitCamel, smallify, search, stringify, shared, smartDedent, stringBreaker, sleep, split, snakeCase, stringArgument, sorted, splitOnce, searchf, secondLine, titleCase, textOrJson, toNumber, toArgument, toNestedArray, test, type, tail, transformObject, trim, testf, toArray, templater, totalOverlap, upperCase, unique, uncapitalize, unzip, wrap, walk, wrapf, xsplit, yes, zip2} from "/home/kdog3682/2023/utils.js"
export {
    inAndOut,
}

function dictSetter(base, ...args) {
    function merge(a, b) {
        if (a === null || a === undefined) {
            return b
        }
        if (isArray(b)) {
            return a.concat(b)
        }
        if (isObject(b)) {
            return deepAssign(a, b)
        }
        return b
    }

    if (isObject(args[0])) {
        return deepAssign(base, args[0])
    }

    let ref = base
    const length = args.length - 1
    for (let i = 0; i < length; i++) {
        const arg = args[i]
        if (i === length - 1) {
            const value = args[i + 1]
            const current = ref[arg]
            ref[arg] = merge(current, value)
            return base
        } else {
            if (!(arg in ref)) {
                ref[arg] = {}
            }
            ref = ref[arg]
        }
    }
}

function dictGetter(base, ...args) {
    const length = args.length
    try {
        if (length === 1) return base[args[0]]
        if (length === 2) return base[args[0]][args[1]]
        if (length === 3) return base[args[0]][args[1]][args[2]]
    } catch (e) {
        return null
    }

    throw new Error('depth 3 is the max for now')
}
function deepAssign(base, o) {
    if (!o) return

    function runner(base, o) {
        for (let [k, v] of Object.entries(o)) {
            base[k] = get(base, k, v)
        }
        return base
    }

    function get(base, k, v) {
        if (k in base) {
            if (isObject(v)) {
                return runner(base[k], v)
            } else if (isArray(v)) {
                return base[k].concat(v)
            } else {
                return v
            }
        } else {
            return v
        }
    }

    return runner(base, o)
}




class Element {
    constructor(state = null, parent = null) {
        this.children = []
        this.state = {}
        this._keys = new Set()
        this._deleted = 0
        if (state) {
            for (let [k, v] of Object.entries(state)) {
                this.set(k, v)
            }
        }
        this.setParent(parent)
    }

    get(...args) {
        return dictGetter(this.state, ...args)
    }

    assign(...args) {
        dictSetter(this.state, ...args)
        return this
    }

    set(k, v) {
        this[k] = v
        this._keys.add(k)
        return this
    }

    setParent(parent) {
        if (parent === null) {
            this.uid = 0
            this.parent = null
        } else {
            this.parent = parent
            this.uid = parent.uid + parent.size + 1
        }
        return this
    }

    get selfIndex() {
        return this.parent.children.indexOf(this)
    }

    get size() {
        return this.children.length
    }

    get root() {
        return this.parent ? this.parent.root : this
    }

    get prevSibling() {
        if (!this.parent || this.parent.size === 1) return null
        const index = this.selfIndex
        return index === 0 ? null : this.parent.children[index - 1]
    }

    get nextSibling() {
        if (!this.parent) return null
        const index = this.selfIndex
        return index + 1 < this.parent.size ? this.parent.children[index + 1] : null
    }

    get siblings() {
        if (!this.parent) return []
        return this.parent.children.filter(x => x !== this)
    }

    get numSiblings() {
        return this.siblings.length
    }

    get firstChild() {
        return this.children[0] || null
    }

    get lastChild() {
        return this.children[this.children.length - 1] || null
    }

    get kind() {
        return this.isBranch() ? 'branch' : 'leaf'
    }

    isLeaf() {
        return this.children.length === 0
    }

    isRoot() {
        return this.uid === 0
    }

    isBranch() {
        return this.children.length > 0
    }

    isFirstChild() {
        return this.parent.firstChild === this
    }

    isLastChild() {
        return this.parent.lastChild === this
    }

    prev() {
        return this.prevSibling || this.parent
    }

    next() {
        return this.firstChild || this.nextSibling
    }

    appendChild(child) {
        const newChild = this.create(child)
        this.children.push(newChild)
        return newChild
    }

    prependChild(child) {
        const newChild = this.create(child)
        this.children.unshift(newChild)
        return newChild
    }

    insertNodeBefore(refNode, node) {
        const newNode = this.create(node)
        const index = refNode.selfIndex
        this.children.splice(index, 0, newNode)
        return newNode
    }

    insertNodeAfter(refNode, node) {
        const newNode = this.create(node)
        const index = refNode.selfIndex + 1
        this.children.splice(index, 0, newNode)
        return newNode
    }

    replaceNode(refNode, node) {
        const newNode = this.create(node)
        this.children[refNode.selfIndex] = newNode
        return newNode
    }

    replaceWith(node) {
        this.parent.children[this.selfIndex] = node
        node.setParent(this.parent)
        const keys = ['state', 'children']
        for (let key of keys) {
            this[key] = node[key]
        }
        return node
    }

    enter() {
        return this.lastChild
    }

    exit(n = 1) {
        let context = this
        for (let i = 0; i <= n; i++) {
            context = context.parent
        }
        return context
    }

    remove() {
        this._deleted = 1
    }

    create(x) {
        return new this.constructor(x, this)
    }

    *traverse() {
        for (let child of this.children) {
            yield* child.traverse()
        }
        if ('text' in this) {
            yield this
        }
    }
}

class StateContext {
    constructor() {
        this.node = new StateContextNode()
        this.root = this.node
        this.ind = 0
    }

    shift(ind) {
        if (ind > this.ind) {
            this.node = this.node.enter()
        } else if (ind < this.ind) {
            this.node = this.node.exit(ind)
        }
        this.ind = ind
    }
}

class StateContextNode extends Element {
    get value() {
        return this.state
    }

    json() {
        const getter = node => node.state

        const callback = node => {
            const data = getter(node)
            const children = node.children.filter(x => x._deleted === 0)
            if (children.length) {
                data['children'] = children.map(callback)
            }
            return data
        }

        return callback(this)
    }
}

function run(s) {
    const fix = items => {
        const store = []
        let c = -1
        while (true) {
            c++
            let item = items[c]
            let newlines = 0
            while (true) {
                if (item.text === '') {
                    newlines++
                    c++
                    item = items[c]
                } else {
                    if (newlines) {
                        store[store.length - 1].newlines = newlines
                    }
                    store.push(item)
                    break
                }
            }
            if (c === items.length - 1) return store
        }
    }

    const lines = s.trim().split('\n')
    const items = lines.map(getIndentAndText)
    const fixedItems = fix(items)

    const context = new StateContext()
    fixedItems.forEach((item, i) => {
        item.index = i
        context.shift(item.ind)
        context.node.appendChild(item)
    })

    return context.root
}

function toNode(x) {
    return isString(x) ? run(x) : x
}
function inAndOut(root, {onLeaf, onBranchEnter, onBranchExit, onEnter, onExit} = {}) {
    const runner = node => {
        const status = onEnter && onEnter(node)
        if (status === false) {
            return 
        }
        if (node.isLeaf()) {
            onLeaf && onLeaf(node)
        } else {
            onBranchEnter && onBranchEnter(node)
            node.children.forEach(runner)
            onBranchExit && onBranchExit(node)
        }
        onExit && onExit(node)
    }

    const node = toNode(root)
    if (node.children.length > 1) {
        node.children.forEach(runner)
        return node.children
    } else {
        runner(node)
        return node
    }
}

